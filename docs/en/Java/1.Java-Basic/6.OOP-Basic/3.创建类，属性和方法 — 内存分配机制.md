# ⭐创建类，属性和方法 — 内存分配机制

# 简单 — 类 + 类属性

## 对象的内存布局

例子：

```java
Cat cat1 = new Cat();
cat1.name = "Nick"; 
cat1.age = 3;
cat1.color = "yellow"
```

<aside>
🔥 堆空间（实际空间）里的才是真正的对象`new Cat();`，其他的都只是引用`cat1`（对象引用）。

</aside>

![堆里面的才是对象实际的空间（类似于数组），可以被多个对象名引用。
cat1是对象名，只是对象引用，储存的是对象的地址值。](%E2%AD%90%E5%88%9B%E5%BB%BA%E7%B1%BB%EF%BC%8C%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%20%E2%80%94%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%209e4c7235558e406681ecdc6b0962e6d7/Untitled.png)

堆里面的才是对象实际的空间（类似于数组），可以被多个对象名引用。
cat1是对象名，只是对象引用，储存的是对象的地址值。

## 对象分配机制

```java
Person p1 = new Person();
p1.age = 22;
p1.name = "Nick";
Person p2 = p1;
System.put.prontln("p2 age is " + p2.age);
// p2 age is 22

p1.age = 30;  // or p2.age = 30;  都是对同一个数值进行操作
System.put.prontln("p2 age is " + p2.age);
// p2 age is 30
```

**开始之前**

1. 加载`Person`类信息到方法区。

`Person p1 = new Person;`

1. 在栈中创建`p1`对象名，此时的值为`null`。
2. 在堆中分配`p1`内存空间（对象本体），并包含对应的`Person`属性。此时属性是默认值。[⭐基本数据类型 Data Type](https://www.notion.so/Data-Type-7decffbb79da4fde9b84dcf864ffcc0a?pvs=21) 
3. 把地址值赋给对象/对象名`p1`。`p1`指向对象。

`p1.age = 22;`

1. 把`p1.age`属性改成22。

`p1.name = "Nick";`

1. 把`p1.name`属性改成”Nick”。

`Person p2 = p1;`

1. 在栈中创建`p2`对象，并把`p1`的地址值赋给`p2`。（`p2`没有创建新的内存空间，它的地址值是`p1`）
    
    ![Untitled](%E2%AD%90%E5%88%9B%E5%BB%BA%E7%B1%BB%EF%BC%8C%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%20%E2%80%94%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%209e4c7235558e406681ecdc6b0962e6d7/Untitled%201.png)
    
    ⭐**其他例子：**[⭐ [练习]类与对象 — 内存分配机制](https://www.notion.so/9a26b3b2dbf6441381a950da4d4c7564?pvs=21) 
    

# 中级 — main 方法 + 类 + 类方法

## 对象的内存布局

<aside>
📌 每当程序执行到方法时（包括main方法），就会**开辟**一个临时的独立的栈空间，用于执行这个方法。
这个独立的栈空间会在方法结束时**删除/释放**掉。

</aside>

```java
Public class Method01{
	public static void main(String[] a){
		Person p1 = new Person();
		int returnResult = p1.getSum(10, 20);  
	}
}

class Person{
	// field
	String name;

	// method
	public int getSum(int num1, int num2){
		int result = n1 + n2;
		return result;
	}
}
```

![1. 每当程序执行到方法时，就会**开辟**一个临时的独立的栈空间，用于执行方法。
2. 顺序执行完方法 或 执行到return后，**释放/删除**这个临时的栈空间。然后继续执行后面的代码。](%E2%AD%90%E5%88%9B%E5%BB%BA%E7%B1%BB%EF%BC%8C%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%20%E2%80%94%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6%209e4c7235558e406681ecdc6b0962e6d7/Untitled%202.png)

1. 每当程序执行到方法时，就会**开辟**一个临时的独立的栈空间，用于执行方法。
2. 顺序执行完方法 或 执行到return后，**释放/删除**这个临时的栈空间。然后继续执行后面的代码。

<aside>
🔥 mian方法也是个方法。当执行完main方法后，也会删除当前方法的栈空间（也就是main），代表退出整个程序。

</aside>